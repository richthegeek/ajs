// Generated by CoffeeScript 1.7.1
(function() {
  var Evaluator, acorn, dir, fs, nodes, path;

  acorn = require('acorn');

  fs = require('fs');

  path = require('path');

  nodes = {};

  dir = path.resolve(__dirname, './tree');

  fs.readdirSync(dir).forEach(function(file) {
    var name;
    if (file.match(/\.(js|coffee)$/)) {
      name = file.split('.').shift();
      return nodes[name] = require(dir + '/' + file);
    }
  });

  module.exports = Evaluator = (function() {
    function Evaluator(target, context, options) {
      var fn, type, _base, _base1;
      this.target = target;
      this.context = context != null ? context : {};
      this.options = options != null ? options : {};
      if ((_base = this.options).inferCallbacks == null) {
        _base.inferCallbacks = true;
      }
      if ((_base1 = this.context)["this"] == null) {
        _base1["this"] = target;
      }
      this.nodes = {};
      for (type in nodes) {
        fn = nodes[type];
        this.nodes[type] = fn.bind(this);
      }
      null;
    }

    Evaluator.prototype["eval"] = function(string, callback) {
      var ast, hash;
      if (Evaluator.cache == null) {
        Evaluator.cache = {};
      }
      hash = require('crypto').createHash('md5').update(string).digest('hex');
      ast = Evaluator.cache[hash] || (ast = acorn.parse(string, this.options));
      return this.recurse(ast.body[0], ast, callback, callback);
    };

    Evaluator.prototype.recurse = function(node, parent, failback, callback) {
      var fn;
      fn = this.nodes[node.type];
      if (fn) {
        node.parent = parent;
        node.context = node.context || node.parent.context || this.context;
        return fn.call(this, node, callback);
      }
      return failback("Undefined node type: " + node.type);
    };

    Evaluator.prototype.recurseAll = function(list, parent, failback, callback) {
      var fn;
      fn = (function(_this) {
        return function(node, next) {
          return _this.recurse(node, parent, next, next);
        };
      })(this);
      return this.each(list, fn, function(err, list) {
        if (err) {
          return failback(err, list);
        } else {
          return callback(null, list);
        }
      });
    };

    Evaluator.prototype.each = function(list, fn, callback) {
      var next;
      next = (function(_this) {
        return function(i) {
          if (i >= list.length) {
            return callback(null, list);
          }
          return fn(list[i], function(err, r) {
            list[i] = r;
            if (err) {
              return callback(err, list);
            }
            return next(i + 1);
          });
        };
      })(this);
      return next(0);
    };

    Evaluator.prototype.get = function(keys, source, failback, callback) {
      var fn;
      if ((source != null ? source.__get : void 0) != null) {
        fn = source.__get.bind(source);
      } else {
        fn = (function(_this) {
          return function(key, next) {
            return next(null, source[key]);
          };
        })(this);
      }
      return this.each(keys, fn, function(err, res) {
        if (err) {
          failback(err, res);
        }
        return callback(null, res);
      });
    };

    return Evaluator;

  })();

  Evaluator.Return = (function() {
    function Return(value) {
      this.value = value;
      null;
    }

    return Return;

  })();

}).call(this);

//# sourceMappingURL=index.map
