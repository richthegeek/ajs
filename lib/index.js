// Generated by CoffeeScript 1.7.1
(function() {
  var Evaluator, acorn, dir, fs, nodes, path;

  acorn = require('acorn');

  fs = require('fs');

  path = require('path');

  nodes = {};

  dir = path.resolve(__dirname, './tree');

  fs.readdirSync(dir).forEach(function(file) {
    var name;
    if (file.match(/\.(js|coffee)$/)) {
      name = file.split('.').shift();
      return nodes[name] = require(dir + '/' + file);
    }
  });

  module.exports = Evaluator = (function() {
    function Evaluator(context, options) {
      var fn, type, _base;
      if (context == null) {
        context = {};
      }
      this.options = options != null ? options : {};
      if (context["this"] == null) {
        context["this"] = {};
      }
      if (context instanceof Evaluator.Context) {
        this.context = context;
      } else {
        this.context = new Evaluator.Context(null, context);
      }
      if ((_base = this.options).inferCallbacks == null) {
        _base.inferCallbacks = true;
      }
      this.nodes = {};
      for (type in nodes) {
        fn = nodes[type];
        this.nodes[type] = fn.bind(this);
      }
      null;
    }

    Evaluator.prototype["eval"] = function(string, callback) {
      var ast, evalLine, hash;
      if (Evaluator.cache == null) {
        Evaluator.cache = {};
      }
      hash = require('crypto').createHash('md5').update(string).digest('hex');
      ast = Evaluator.cache[hash] || (ast = acorn.parse(string, this.options));
      evalLine = (function(_this) {
        return function(line, next) {
          return _this.recurse(line, ast, next, next);
        };
      })(this);
      return this.each(ast.body, evalLine, function(err, rows) {
        if (Array.isArray(rows)) {
          return callback(err, rows[rows.length - 1]);
        }
        return callback(err, rows);
      });
    };

    Evaluator.prototype.recurse = function(node, parent, failback, callback) {
      var fn;
      fn = this.nodes[node.type];
      if (fn) {
        node.parent = parent;
        node.context = node.context || node.parent.context || this.context;
        return fn.call(this, node, callback);
      }
      return failback("Undefined node type: " + node.type);
    };

    Evaluator.prototype.recurseAll = function(list, parent, failback, callback) {
      var fn;
      fn = (function(_this) {
        return function(node, next) {
          return _this.recurse(node, parent, next, next);
        };
      })(this);
      return this.each(list, fn, function(err, list) {
        if (err) {
          return failback(err, list);
        } else {
          return callback(null, list);
        }
      });
    };

    Evaluator.prototype.each = function(list, fn, callback) {
      var next;
      next = (function(_this) {
        return function(i) {
          if (i >= list.length) {
            return callback(null, list);
          }
          return fn(list[i], function(err, r) {
            list[i] = r;
            if (err) {
              return callback(err, list);
            }
            return next(i + 1);
          });
        };
      })(this);
      return next(0);
    };

    return Evaluator;

  })();

  Evaluator.Context = (function() {
    function Context(parent, data) {
      this.parent = parent;
      this.data = data != null ? data : {};
      this.keys = {};
      Object.keys(this.data).forEach((function(_this) {
        return function(k) {
          return _this.keys[k] = true;
        };
      })(this));
      null;
    }

    Context.prototype.get = function(key, callback) {
      if (this.keys[key]) {
        return callback(null, this.data[key]);
      }
      if (this.parent) {
        return this.parent.get(key, callback);
      }
      return callback(null, void 0);
    };

    Context.prototype.set = function(key, value, callback) {
      var target;
      target = this;
      while (target) {
        if (target.keys[key]) {
          return callback(null, target.data[key] = value);
        }
        target = target.parent;
      }
      this.keys[key] = true;
      return callback(null, this.data[key] = value);
    };

    Context.prototype.unset = function(key, callback) {
      var target;
      target = this;
      while (target) {
        if (target.keys[key]) {
          target.keys[key] = false;
          return callback(null, delete target.data[key]);
        }
        target = target.parent;
      }
      this.keys[key] = false;
      return callback(null, delete this.data[key]);
    };

    return Context;

  })();

  Evaluator.Return = (function() {
    function Return(value) {
      this.value = value;
      null;
    }

    return Return;

  })();

}).call(this);

//# sourceMappingURL=index.map
